// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     cpp_templates/function/FUNCTION.h.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#pragma once

#include <Eigen/Dense>

namespace sym {

/**
 * This function was autogenerated. Do not modify by hand.
 *
 * Args:
 *     states: Matrix17_1
 *     update: Matrix15_1
 *
 * Outputs:
 *     next_states: Matrix17_1
 */
template <typename Scalar>
void AhrsUpdateRetract(const Eigen::Matrix<Scalar, 17, 1>& states,
                       const Eigen::Matrix<Scalar, 15, 1>& update,
                       Eigen::Matrix<Scalar, 17, 1>* const next_states = nullptr) {
  // Total ops: 94

  // Input arrays

  // Intermediate terms (15)
  const Scalar _tmp0 =
      std::sqrt(Scalar(std::pow(update(0, 0), Scalar(2)) + std::pow(update(1, 0), Scalar(2)) +
                       std::pow(update(2, 0), Scalar(2)) + Scalar(9.9999999999999998e-17)));
  const Scalar _tmp1 = (Scalar(1) / Scalar(2)) * _tmp0;
  const Scalar _tmp2 = std::sin(_tmp1) / _tmp0;
  const Scalar _tmp3 = _tmp2 * update(0, 0);
  const Scalar _tmp4 = _tmp2 * update(1, 0);
  const Scalar _tmp5 = _tmp2 * update(2, 0);
  const Scalar _tmp6 = std::cos(_tmp1);
  const Scalar _tmp7 =
      std::sqrt(Scalar(std::pow(update(12, 0), Scalar(2)) + std::pow(update(13, 0), Scalar(2)) +
                       std::pow(update(14, 0), Scalar(2)) + Scalar(9.9999999999999998e-17)));
  const Scalar _tmp8 = (Scalar(1) / Scalar(2)) * _tmp7;
  const Scalar _tmp9 = std::cos(_tmp8);
  const Scalar _tmp10 = std::sin(_tmp8) / _tmp7;
  const Scalar _tmp11 = _tmp10 * states(16, 0);
  const Scalar _tmp12 = _tmp10 * states(14, 0);
  const Scalar _tmp13 = _tmp10 * states(15, 0);
  const Scalar _tmp14 = _tmp10 * states(13, 0);

  // Output terms (1)
  if (next_states != nullptr) {
    Eigen::Matrix<Scalar, 17, 1>& _next_states = (*next_states);

    _next_states(0, 0) =
        _tmp3 * states(3, 0) - _tmp4 * states(2, 0) + _tmp5 * states(1, 0) + _tmp6 * states(0, 0);
    _next_states(1, 0) =
        _tmp3 * states(2, 0) + _tmp4 * states(3, 0) - _tmp5 * states(0, 0) + _tmp6 * states(1, 0);
    _next_states(2, 0) =
        -_tmp3 * states(1, 0) + _tmp4 * states(0, 0) + _tmp5 * states(3, 0) + _tmp6 * states(2, 0);
    _next_states(3, 0) =
        -_tmp3 * states(0, 0) - _tmp4 * states(1, 0) - _tmp5 * states(2, 0) + _tmp6 * states(3, 0);
    _next_states(4, 0) = states(4, 0) + update(3, 0);
    _next_states(5, 0) = states(5, 0) + update(4, 0);
    _next_states(6, 0) = states(6, 0) + update(5, 0);
    _next_states(7, 0) = states(7, 0) + update(6, 0);
    _next_states(8, 0) = states(8, 0) + update(7, 0);
    _next_states(9, 0) = states(9, 0) + update(8, 0);
    _next_states(10, 0) = states(10, 0) + update(9, 0);
    _next_states(11, 0) = states(11, 0) + update(10, 0);
    _next_states(12, 0) = states(12, 0) + update(11, 0);
    _next_states(13, 0) = _tmp11 * update(12, 0) + _tmp12 * update(14, 0) - _tmp13 * update(13, 0) +
                          _tmp9 * states(13, 0);
    _next_states(14, 0) = _tmp11 * update(13, 0) + _tmp13 * update(12, 0) - _tmp14 * update(14, 0) +
                          _tmp9 * states(14, 0);
    _next_states(15, 0) = _tmp11 * update(14, 0) - _tmp12 * update(12, 0) + _tmp14 * update(13, 0) +
                          _tmp9 * states(15, 0);
    _next_states(16, 0) = -_tmp12 * update(13, 0) - _tmp13 * update(14, 0) -
                          _tmp14 * update(12, 0) + _tmp9 * states(16, 0);
  }
}  // NOLINT(readability/fn_size)

// NOLINTNEXTLINE(readability/fn_size)
}  // namespace sym
